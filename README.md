Proviamo a mergiare
# 1D multichannel convolution accelerator

This repository contains the code for a 1D multichannel convolution accelerator.

## Description

You should design and implement the accelerator as described in the assignment.

To guide you in the implementation, we provide you with a set of files that you should use as a starting point. You can find these files in the following directories:

- `hw/` contains the source files for the accelerator.
- `sw/` contains the C code with the status and control registers of the accelerator.
- `tb/` contains the testbench for the accelerator.
- `util/` contains the vendor script to get the dependencies.

In the files provided, you will find some `TODO`s that you should complete to implement the accelerator.

### Configuration registers

The accelerator shall be controlled by software using the configuration registers defined in [`control_reg.hjson`](./hw/control-reg/data/control_reg.hjson). This file contains a description of each control or status register and their fields. If you add or modify the existing registers. The [`regtool.py`](./hw/vendor/pulp-platform-register-interface/vendor/lowrisc_opentitan/util/regtool.py) scripts from OpenTitan can read the `.hjson` register description and generate the corresponding RTL description ([here](./hw/control-reg/rtl/conv1d_control_reg_top.sv)) and documentation ([here](sw/conv1d_control_reg.md)). If you change or modify the `control_reg.hjson` register description, you must re-generate the RTL description and the register documentation before compiling the simulation model. To ease the process, this can be done with the following `make` targets from the repository root directory, without calling `regtool.py` directly:
```bash
make gen-registers
make verilator-build
```

The [`conv1d_control_reg.sv`](./hw/control-reg/conv1d_control_reg.sv) works as a wrapper for the files automatically generated by the `gen-registers` target. The module described in this file is already instantiated inside the top-level module of the accelerator [`conv1d_obi.sv`](./hw/conv1d_obi.sv). If you add registers, specifically those interacting with the hardware accelerator through dedicated signals, you probably need to also update the `conv1d_control_reg.sv` accordingly.

## Makefile description

The Makefile provided in the root directory of the repository contains the following targets:

- `verilator-build` compiles the testbench and the accelerator HDL code using __Verilator__.
- `verilator-run` compiles and runs the testbench using __Verilator__.
- `verilator-run` runs the testbench using __Verilator__.
- `gen-data` generates the input data for the accelerator.
- `waves` opens *gtkwave* to visualize the waveforms.
- `gen-registers` generates the register map for the accelerator.
- `lint` runs the linter on the accelerator code.
- `format` formats the accelerator code.
- `vendor-update` updates the vendor dependencies.
- `clean` removes all the generated files.

## Running the simulation

You can decide how to verify the correctness of the accelerator. You can use the provided testbench or write your own.

> __Hint:__ The provided testbench simulates the OBI protocol, so you can provide the input data to the accelerator by issuing write transactions to the accelerator memory and configure the accelerator by writing to the status and control registers.

You can also use the provided input data or generate your own. To generate the input data, you can use the `gen-data` target, it will call the makefile in the `tb/` directory to call the `datagen.py` script, it accepts the following arguments:

- `--in_ch` to specify the number of input channels.
- `--in_len` to specify the length of the input data.
- `--k_len` to specify the length of the kernel.
- `--k_num` to specify the number of filters.
- `--stride` to specify the stride of the convolution.
- `--padding` to specify the padding of the convolution.
- `--seed` to specify the seed for the random number generator (can be usefull to use always the same seed and get deterministic numbers).

[`datagen.py`](./tb/datagen.py) will generate two files, `data.c` and `data.h`, in the `tb/` directory. These files contain the declaration and definition of random input samples and the corresponding golden result. You can include the file in your __Verilator__ testbench to read the input data, send it to your accelerator (the DUT), and compare the results with the golden model.

The provided testbench already implements a minimal test program that simply loads the sample random data generated by `datagen.py` into the accelerator internal memory and reads it back to check that the write process was successful. If you decide to use it instead of developing your own testbench, you must expand this test program with the missing steps:
- Copy the input filter(s) into the accelerator private memory (at a different address than the data) and verify that the operation completed successfully.
- Write the necessary configuration registers of the accelerator to make it compute the convolution on the provided data.
- Wait for the acceleration to complete (e.g., by reading a `done` bit inside its configuration registers).
- Verify that the accelerator outputs (stored in its private memory at an address that you decide) match the golden results from `data.h`.

To generate random input data and launch the simulation using Verilator, use the use the following commands:
```bash
make gen-data APP_PARAMS="--in_len 8 --in_ch 4 --k_len 3 --k_num 2" # change the parameters as you wish
make verilator-sim
```

## Once you are done with the implementation

Use Vendor to import the accelerator into the provided platform and integrate it with the provided software.
